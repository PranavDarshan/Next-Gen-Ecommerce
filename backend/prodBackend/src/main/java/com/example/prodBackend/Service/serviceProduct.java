package com.example.prodBackend.Service;

import com.example.prodBackend.DTO.TransactionRequest;
import com.example.prodBackend.Model.*;
import com.example.prodBackend.Repo.*;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import org.json.JSONException;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.google.gson.JsonArray;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.Base64;
import java.util.concurrent.CompletableFuture;
import java.sql.Time;
import java.sql.Date;
import org.json.JSONObject;


@Service
public class serviceProduct {
    @Autowired
    private productRepo repo;
    @Autowired
    private brandRepo brandrepo;
    @Autowired
    private transactionRepo transactionrepo;
    @Autowired
    private productTransactionRepo productTransactionrepo;
    @Autowired
    private customersRepo customersrepo;
    @Autowired
    private storeRepo storerepo;

    @Autowired
    GroqLanguageModelService groqService;
    @Autowired
    transactionRepo transactionRepository;
    public Product addProduct(Product products) {
        return repo.save(products);
    }

    private static final String API_KEY = "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";
    private static final String API_ENDPOINT = "https://api.groq.com/openai/v1/chat/completions";

    public CompletableFuture<String> analyzeImage(Path imagePath, String prompt) {
        try {
            // Read image and encode to base64
            byte[] imageBytes = Files.readAllBytes(imagePath);
            String base64Image = Base64.getEncoder().encodeToString(imageBytes);

            // Construct the JSON payload for vision model using Gson
            JsonObject requestBody = new JsonObject();
            requestBody.addProperty("model", "llama-3.2-90b-vision-preview");

            JsonArray messages = new JsonArray();
            JsonObject userMessage = new JsonObject();
            userMessage.addProperty("role", "user");

            JsonArray contentArray = new JsonArray();

            // Text content
            JsonObject textContent = new JsonObject();
            textContent.addProperty("type", "text");
            textContent.addProperty("text", prompt);
            contentArray.add(textContent);

            // Image content
            JsonObject imageContent = new JsonObject();
            imageContent.addProperty("type", "image_url");

            JsonObject imageUrlObject = new JsonObject();
            imageUrlObject.addProperty("url", "data:image/jpeg;base64," + base64Image);
            imageContent.add("image_url", imageUrlObject);

            contentArray.add(imageContent);

            userMessage.add("content", contentArray);
            messages.add(userMessage);

            requestBody.add("messages", messages);
            requestBody.addProperty("max_tokens", 1024);

            // Create HTTP client and request
            HttpClient client = HttpClient.newHttpClient();
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(API_ENDPOINT))
                    .header("Content-Type", "application/json")
                    .header("Authorization", "Bearer " + API_KEY)
                    .POST(HttpRequest.BodyPublishers.ofString(new Gson().toJson(requestBody)))
                    .build();

            // Send request and process response
            return client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                    .thenApply(response -> {
                        if (response.statusCode() != 200) {
                            throw new RuntimeException("Groq API Error: " + response.body());
                        }
                        return extractResponseFromJson(response.body());
                    });

        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    public String consolidateWithGroqModel(String combinedJson) {
        String prompt = "Given the following JSON information, consolidate all the data into a single JSON object with the following attributes: brandName, brandDescription, brandFoundationYear, brandCountry, productName, description, price, nutritionalInformation, and category. The productId can be autogenerated.\n" +
                "Please only generate the final consolidated JSON and nothing else. Ensure the output starts with an opening curly bracket '{':\n" +
                "brandName: Use the existing brand name\n" +
                "brandDescription: Combine the existing brand description if available, otherwise assume based on brand context\n" +
                "brandFoundationYear: Extract the foundation year from the provided JSON, if not available, assume a plausible year\n" +
                "brandCountry: Extract the country from the provided JSON, if not available, assume a plausible country\n" +
                "productName: Combine the existing product name\n" +
                "description: Combine the existing description\n" +
                "price: Extract the price range from the provided JSON, if not available, assume a value in rupees and output only the number and nothing else\n" +
                "nutritionalInformation: Use the existing nutritional information provided in the JSON (calories, fat, protein, carbohydrates)\n" +
                "category: Use the existing product category (\"snack\")\n" +
                "The final JSON should be formatted starting with a bracket '{':\n\n" +
                "{\n" +
                "    \"brandName\": \"BRAND_NAME\",\n" +
                "    \"brandDescription\": \"BRAND_DESCRIPTION\",\n" +
                "    \"brandFoundationYear\": \"FOUNDATION_YEAR\",\n" +
                "    \"brandCountry\": \"BRAND_COUNTRY\",\n" +
                "    \"productName\": \"SPECIFIC_PRODUCT_NAME\",\n" +
                "    \"description\": \"PRODUCT_DESCRIPTION\",\n" +
                "    \"price\": \"PRODUCT_PRICE\",\n" +
                "    \"nutritionalInformation\": {\n" +
                "        \"calories\": \"CALORIES_CONTENT\",\n" +
                "        \"fat\": \"FAT_CONTENT\",\n" +
                "        \"protein\": \"PROTEIN_CONTENT\",\n" +
                "        \"carbohydrates\": \"CARBOHYDRATES_CONTENT\"\n" +
                "    },\n" +
                "    \"category\": \"PRODUCT_CATEGORY\"\n" +
                "}";


        // Call the Groq model with the prompt and combinedJson
        return groqService.callModel(prompt, combinedJson);
    }


    private String extractResponseFromJson(String jsonResponse) {
        try {
            JsonObject responseObject = new Gson().fromJson(jsonResponse, JsonObject.class);
            return responseObject
                    .getAsJsonArray("choices")
                    .get(0)
                    .getAsJsonObject()
                    .getAsJsonObject("message")
                    .get("content")
                    .getAsString();
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse response: " + jsonResponse, e);
        }
    }



    public Product jsonProductNameAndSave(String resultJson) {
        try {
            // Parse the input JSON to extract the product name and brand name
            JSONObject combinedResult = new JSONObject(resultJson);
            System.out.println(combinedResult);
            String productName = combinedResult.getString("productName");
            String brandName = combinedResult.getString("brandName");

            System.out.println(productName);
            Product producth = repo.findByProductName(productName);
            if (producth == null) {
                throw new RuntimeException("Product not found");
            }

            // Return the found product without modifying stock or creating transactions
            return producth;

        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Error processing the product: " + e.getMessage());
        }
    }









    public String jsonExtractAndSaveProduct(String combinedResultJson) {
        try {
            // Parse the combinedResult JSON string
            JSONObject combinedResult = new JSONObject(combinedResultJson);

            // Extract product details from prompt1
            String productName = combinedResult.getString("productName");
            String description = combinedResult.getString("description");

            // Extract nutritional information and category from prompt2
            JSONObject nutritionalInfoJson = combinedResult.getJSONObject("nutritionalInformation");
            String nutritionalInformation = nutritionalInfoJson.toString(); // Storing as JSON string

            String category = combinedResult.getString("category");
            double price = combinedResult.getDouble("price"); // Assuming it's numeric in prompt2

            // Extract brandName from the JSON
            String brandName = combinedResult.getString("brandName");

            // Search for the Brand by name
            Brand brand = brandrepo.findByBrandName(brandName);

            // If the brand doesn't exist, handle it (create a new brand or throw an exception)
            if (brand == null) {
                // You can either throw an exception, or create a new brand here
                throw new RuntimeException("Brand with name " + brandName + " not found");
                // Alternatively, create a new Brand entry:
                // brand = new Brand();
                // brand.setBrandName(brandName);
                // brand.setBrandDescription("No description available"); // Default value
                // brand.setBrandFoundationYear(2000); // Default plausible year
                // brand.setBrandCountry("Unknown"); // Default plausible country
                // brandRepository.save(brand);
            }

            // Create and save the Product entity
            Product product = new Product();
            product.setProductName(productName);
            product.setDescription(description);
            product.setPrice(price);
            product.setCategory(category);
            product.setNutritonalInformation(nutritionalInformation);
            product.setStock(1); // Default stock value, change as needed

            // Set the brand for the product
            product.setBrand(brand);

            // Save the product in the database
            repo.save(product);

            return "Product saved successfully with Brand: " + brandName;
        } catch (JSONException e) {
            return "Failed to parse JSON: " + e.getMessage();
        } catch (RuntimeException e) {
            return "Failed to save product: " + e.getMessage();
        }
    }




    public String jsonExtractAndSaveBrand(String combinedResultJson) {
        try {
            // Parse the combinedResult JSON string
            JSONObject combinedResult = new JSONObject(combinedResultJson);

            // Extract brand details from the JSON
            String brandName = combinedResult.getString("brandName");
            String brandDescription = combinedResult.getString("brandDescription");
            int brandFoundationYear = combinedResult.getInt("brandFoundationYear");
            String brandCountry = combinedResult.getString("brandCountry");

            // Create and save the brand entity
            Brand brand = new Brand();
            brand.setBrandName(brandName);
            brand.setBrandDescription(brandDescription);
            brand.setBrandFoundationYear(brandFoundationYear);
            brand.setBrandCountry(brandCountry);

            // Save the brand in the database
            brandrepo.save(brand);

            return "Brand saved successfully!";
        } catch (JSONException e) {
            return "Failed to parse JSON: " + e.getMessage();
        }
    }


    public Product updateStock(String productName, int newStock) {
        System.out.println(productName);
        Product product = repo.findByProductName(productName);
        product.setStock(newStock);
        return repo.save(product);
    }




        public Transaction processTransaction(TransactionRequest request) {
            // Create and save ProductTransaction first
            productTransaction productTransaction = new productTransaction();
            productTransaction.setQuantity(request.getQuantity());
            productTransaction.setUnitPrice(request.getUnitPrice());
            productTransaction.setProductId(Math.toIntExact(request.getProductId()));
            // Note: You would need to set productId based on your business logic

            customers customer = customersrepo.findByCustomerId(request.getCustomerId());
            Store store = storerepo.findByStoreId(request.getStoreId());

            // Create and save Transaction
            Transaction transaction = new Transaction();
            transaction.setStore(store);
            transaction.setCustomer(customer);
            transaction.settTime(Time.valueOf(LocalTime.now()));
            transaction.settDate(Date.valueOf(LocalDate.now()));

            // Save transaction to get the ID
            transaction = transactionrepo.save(transaction);

            // Set the transaction ID in product transaction and save
            productTransaction.setTransactionId(transaction.getTransactionId());
            productTransactionrepo.save(productTransaction);

            return transaction;
    }

//    public Product reduceStock()
}

